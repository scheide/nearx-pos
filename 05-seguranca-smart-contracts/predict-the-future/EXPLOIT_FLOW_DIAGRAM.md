# Exploit Flow Diagram: PredictTheFutureChallenge

This document provides a step-by-step visual explanation of how an attacker exploits the contract.

## Attack Flow: Predictable Randomness Exploit

### Step-by-Step Attack

```
┌─────────────────────────────────────────────────────────────────┐
│                    INITIAL STATE                                 │
│  Contract Balance: 1 ETH                                        │
│  Attacker Balance: 1 ETH                                        │
│  No guesses locked                                              │
└─────────────────────────────────────────────────────────────────┘
                            │
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│  STEP 1: Attacker Locks in Guess                                │
│  ────────────────────────────────────────────────────────────  │
│  Transaction: lockInGuess(5) with 1 ETH                        │
│                                                                  │
│  Code Execution:                                                │
│    require(guesser == address(0));  ✅ Pass                    │
│    require(msg.value == 1 ether);   ✅ Pass                    │
│    guesser = msg.sender;            ✅ Set                     │
│    guess = 5;                       ✅ Set                     │
│    settlementBlockNumber = 101;     ✅ Set                     │
│                                                                  │
│  Result:                                                         │
│    Contract Balance: 2 ETH                                      │
│    Attacker Balance: 0 ETH                                      │
│    guesser = attacker_address                                   │
│    guess = 5                                                     │
│    settlementBlockNumber = 101                                   │
└─────────────────────────────────────────────────────────────────┘
                            │
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│  STEP 2: Wait for Settlement Block                              │
│  ────────────────────────────────────────────────────────────  │
│  Current Block: 100                                             │
│  Settlement Block: 101                                          │
│                                                                  │
│  Attacker waits for block 101 to be mined...                    │
│                                                                  │
│  Block 101 is mined:                                            │
│    blockhash(100) = 0x1234abcd...  (NOW PUBLICLY KNOWN)        │
│    block.timestamp = 1699123456    (NOW PUBLICLY KNOWN)        │
└─────────────────────────────────────────────────────────────────┘
                            │
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│  STEP 3: Attacker Calculates Answer (THE EXPLOIT)              │
│  ────────────────────────────────────────────────────────────  │
│  Current Block: 102                                             │
│                                                                  │
│  Attacker's Calculation:                                        │
│    blockhash(101) = 0x5678efgh...  (PUBLICLY KNOWN)            │
│    block.timestamp = 1699123468    (PUBLICLY KNOWN)            │
│                                                                  │
│    hash = keccak256(                                            │
│      abi.encodePacked(                                          │
│        0x5678efgh...,  // blockhash(101)                        │
│        1699123468     // block.timestamp                        │
│      )                                                          │
│    )                                                            │
│                                                                  │
│    answer = uint8(uint256(hash) % 10)                           │
│    answer = 7  (for example)                                    │
│                                                                  │
│  Attacker's Decision:                                           │
│    guess = 5                                                    │
│    answer = 7                                                   │
│    5 != 7  ❌ DOES NOT MATCH                                    │
│                                                                  │
│  Action: Wait for next block and try again                      │
└─────────────────────────────────────────────────────────────────┘
                            │
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│  STEP 4: Attacker Calls settle() (Wrong Guess)                 │
│  ────────────────────────────────────────────────────────────  │
│  Transaction: settle()                                          │
│                                                                  │
│  Code Execution:                                                │
│    require(msg.sender == guesser);        ✅ Pass              │
│    require(block.number > 101);           ✅ Pass (block 102)  │
│                                                                  │
│    answer = calculateAnswer() = 7                               │
│                                                                  │
│    guesser = address(0);  ⚠️ STATE RESET (Issue #2)            │
│                                                                  │
│    if (5 == 7) {  ❌ FALSE                                     │
│      transfer(2 ether);  // NOT EXECUTED                        │
│    }                                                            │
│                                                                  │
│  Result:                                                         │
│    Contract Balance: 2 ETH  (unchanged)                         │
│    Attacker Balance: 0 ETH  (unchanged)                         │
│    guesser = address(0)  ⚠️ RESET (can try again!)             │
│                                                                  │
│  Cost to Attacker: Only gas fees (~$0.10)                       │
└─────────────────────────────────────────────────────────────────┘
                            │
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│  STEP 5: Attacker Locks New Guess (Issue #2 Exploitation)      │
│  ────────────────────────────────────────────────────────────  │
│  Current Block: 103                                             │
│                                                                  │
│  Attacker calculates answer for block 103:                      │
│    answer = keccak256(blockhash(102), timestamp) % 10 = 7      │
│                                                                  │
│  Attacker's Strategy:                                           │
│    Since answer = 7, lock in guess = 7                          │
│                                                                  │
│  Transaction: lockInGuess(7) with 1 ETH                        │
│                                                                  │
│  Code Execution:                                                │
│    require(guesser == address(0));  ✅ Pass (was reset!)       │
│    require(msg.value == 1 ether);   ✅ Pass                    │
│    guesser = attacker_address;      ✅ Set                     │
│    guess = 7;                      ✅ Set (matches answer!)    │
│    settlementBlockNumber = 104;    ✅ Set                      │
│                                                                  │
│  Result:                                                         │
│    Contract Balance: 3 ETH  (2 ETH + 1 ETH new deposit)        │
│    Attacker Balance: 0 ETH                                      │
│    guess = 7  (matches predicted answer!)                       │
└─────────────────────────────────────────────────────────────────┘
                            │
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│  STEP 6: Attacker Wins                                          │
│  ────────────────────────────────────────────────────────────  │
│  Current Block: 104                                             │
│                                                                  │
│  Attacker calculates answer for block 104:                      │
│    answer = keccak256(blockhash(103), timestamp) % 10 = 7      │
│                                                                  │
│  Attacker's Decision:                                           │
│    guess = 7                                                    │
│    answer = 7                                                   │
│    7 == 7  ✅ MATCHES!                                          │
│                                                                  │
│  Transaction: settle()                                          │
│                                                                  │
│  Code Execution:                                                │
│    require(msg.sender == guesser);        ✅ Pass              │
│    require(block.number > 104);           ✅ Pass (block 105)  │
│                                                                  │
│    answer = calculateAnswer() = 7                               │
│                                                                  │
│    guesser = address(0);                                        │
│                                                                  │
│    if (7 == 7) {  ✅ TRUE                                      │
│      transfer(2 ether);  ✅ EXECUTED                            │
│    }                                                            │
│                                                                  │
│  Result:                                                         │
│    Contract Balance: 1 ETH  (3 ETH - 2 ETH payout)             │
│    Attacker Balance: 2 ETH  (received payout)                  │
│                                                                  │
│  Attacker's Profit:                                             │
│    Deposited: 2 ETH  (1 ETH initial + 1 ETH second guess)      │
│    Received: 2 ETH                                              │
│    Net: 0 ETH  (but could repeat with remaining 1 ETH)         │
│                                                                  │
│  Actually, if attacker is smart:                                │
│    - They predict answer FIRST                                  │
│    - Only lock in guess when answer matches                     │
│    - Win on first attempt                                       │
│    - Profit: 1 ETH (2 ETH received - 1 ETH deposited)          │
└─────────────────────────────────────────────────────────────────┘
```

## Simplified Attack (Optimal Strategy)

A smarter attacker would:

```
1. Monitor blockchain for upcoming blocks
2. Calculate: answer = keccak256(blockhash(N-1), timestamp) % 10
3. If answer matches a guess they want to make:
   a. Immediately call lockInGuess(answer) in that block
   b. Wait for settlement block
   c. Call settle() and win
4. If answer doesn't match, wait for next block
5. Repeat until win

Result: Guaranteed win, 1 ETH profit per cycle
```

## Why This Works

### The Fundamental Flaw

```
Answer Calculation (in settle()):
  answer = keccak256(blockhash(block.number - 1), block.timestamp) % 10

Key Insight:
  - blockhash(block.number - 1) is KNOWN once block N-1 is mined
  - block.timestamp is KNOWN once block N is mined
  - Attacker can calculate answer BEFORE calling settle()
  - Attacker can calculate answer BEFORE locking in guess (in next block)
```

### The State Reset Flaw

```
After settle() is called:
  - guesser is reset to address(0) REGARDLESS of win/loss
  - Attacker can immediately lock in a new guess
  - No cooldown, no penalty, no restriction
  - Combined with predictability = guaranteed win
```

## Prevention: Commit-Reveal Scheme

```
┌─────────────────────────────────────────────────────────────────┐
│              COMMIT-REVEAL SCHEME FLOW                          │
└─────────────────────────────────────────────────────────────────┘

STEP 1: COMMIT PHASE
  ──────────────────
  User generates secret: 0xabcd1234...
  User calculates: commitment = keccak256(guess=5, secret=0xabcd...)
  User calls: commitGuess(commitment) with 1 ETH
  
  At this point:
    ✅ Commitment is locked (cannot change guess)
    ✅ Answer is UNKNOWN (depends on future blocks)
    ✅ User cannot predict answer (future blocks don't exist)
    ❌ User cannot change guess (committed to hash)

STEP 2: REVEAL PHASE (After commitment period)
  ──────────────────
  User calls: revealGuess(guess=5, secret=0xabcd...)
  
  Contract verifies:
    ✅ keccak256(5, 0xabcd...) == commitment
    ✅ Store guess = 5
  
  At this point:
    ✅ Guess is revealed and stored
    ✅ Answer is still UNKNOWN (settlement block not reached)
    ✅ User cannot change guess (already revealed)

STEP 3: SETTLEMENT PHASE (After settlement block)
  ──────────────────
  User calls: settle()
  
  Contract calculates:
    answer = keccak256(blockhash(settlementBlock-1), timestamp) % 10
  
  At this point:
    ✅ Answer is calculated from FUTURE block (unpredictable at commit time)
    ✅ User was committed to guess before answer was known
    ✅ Fair game - cannot predict or manipulate

RESULT:
  ✅ User cannot predict answer when committing
  ✅ User cannot change guess after committing
  ✅ Answer depends on future blocks (unpredictable)
  ✅ Fair and secure system
```

## Key Differences

| Aspect | Original (Vulnerable) | Fixed (Commit-Reveal) |
|--------|----------------------|----------------------|
| **Guess Commitment** | Direct (guess=5) | Hashed (keccak256(guess, secret)) |
| **Predictability** | Answer known before settle() | Answer unknown at commit time |
| **State Reset** | Reset even on wrong guess | Reset only after settlement |
| **Retry Ability** | Unlimited retries | One attempt per commitment |
| **Security** | ❌ Exploitable | ✅ Secure |
| **Fairness** | ❌ Unfair | ✅ Fair |

## Conclusion

The original contract is fundamentally broken because:
1. The answer can be calculated before calling `settle()`
2. The state resets allow unlimited retries
3. Combined, these allow guaranteed exploitation

The commit-reveal scheme fixes this by:
1. Committing to a hash (cannot change guess)
2. Calculating answer from future blocks (unpredictable)
3. Proper state management (one attempt per commitment)

This makes the system secure and fair.

